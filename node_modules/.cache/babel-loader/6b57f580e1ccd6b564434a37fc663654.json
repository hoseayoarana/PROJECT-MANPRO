{"ast":null,"code":"var _jsxFileName = \"D:\\\\Documents\\\\MANPRO\\\\PROJ FIX\\\\FIX\\\\footprint-calculator-masta(rev)\\\\src\\\\components\\\\Maps\\\\map.jsx\";\nimport React from 'react';\nimport { Map, InfoWindow, GoogleApiWrapper } from 'google-maps-react';\nexport class MapContainer extends React.Component {\n  // travel modes:\n  //  - driving\n  //  - bicycling\n  //  - transit\n  //  - walking\n  constructor(props) {\n    super(props);\n\n    this.renderMapWithTMode = (travelMode = this.props.travelMode, option, time) => {\n      console.log('Should update! Travel mode is ' + travelMode);\n      var responsePromise = this.getFootprint(this.directionsService, this.props.origin, this.props.destination, //   this.props.setEmittedCO2,\n      travelMode, option, time);\n      this.setState({\n        shouldUpdate: false\n      });\n      this.props.setShouldUpdateMap(false);\n      responsePromise.then(promise => {\n        this.props.setEmittedCO2(promise.footprint);\n        this.directionsDisplay.setDirections(promise.response);\n      });\n    };\n\n    this.state = {\n      travelMode: props.travelMode //   shouldUpdate: false\n\n    };\n    this.google = this.props.google;\n    this.directionsService = new this.google.maps.DirectionsService();\n  }\n\n  onMapClicked() {\n    const origin = this.props.origin;\n    const destination = this.props.destination;\n    const setCO2 = this.props.setEmittedCO2;\n\n    if (!destination || !origin) {\n      return;\n    }\n\n    const DirectionsDisplay = this.directionsDisplay;\n    var footprintPromises = [this.getFootprint(this.directionsService, origin, destination, 'TRANSIT' // setCO2\n    ), this.getFootprint(this.directionsService, origin, destination, 'DRIVING' // setCO2\n    ), this.getFootprint(this.directionsService, origin, destination, 'WALKING' // setCO2\n    ), this.getFootprint(this.directionsService, origin, destination, 'BICYCLING' // setCO2\n    )];\n    Promise.all(footprintPromises).then(arr => {\n      console.log(arr);\n      var footprints = arr.reduce((acc, curr) => {\n        acc[curr.travelMode] = curr;\n        return acc;\n      }, {});\n      var bestRoute = footprints['DRIVING']; // if walking to feasible\n\n      if (footprints['WALKING'].duration < 30) {\n        bestRoute = footprints['WALKING'];\n      } else {\n        if (footprints['BICYCLING'].duration < 45) {\n          bestRoute = footprints['BICYCLING'];\n        } else {\n          if (footprints['TRANSIT'].footprint <= footprints['DRIVING'].footprint && footprints['TRANSIT'].duration - footprints['DRIVING'].duration < 30) {\n            bestRoute = footprints['TRANSIT'];\n          }\n        }\n      }\n\n      console.log(bestRoute);\n      this.props.setTravelMode(bestRoute.travelMode);\n      this.props.setEmittedCO2(bestRoute.footprint);\n      DirectionsDisplay.setDirections(bestRoute.response); // window.alert(`${bestRoute.travelMode}: footprint: ${bestRoute.footprint}kg`);\n    }); // function getFootprint(travelMode) {\n    //     return new Promise((resolve, reject) => {\n    //         DirectionsService.route({\n    //             origin: origin,\n    //             destination: destination,\n    //             travelMode: travelMode,\n    //             provideRouteAlternatives: true,\n    //             transitOptions: {\n    //                 departureTime: new Date()\n    //             }\n    //         }, (response, status) => {\n    //             if (status === 'OK') {\n    //                 const distances = response.routes.map(route => {\n    //                     return parseFloat(route.legs[0].distance.text.split(' ')[0], 10);\n    //                 });\n    //                 const durations = response.routes.map(route => {\n    //                     var hours = parseFloat((route.legs[0].duration.text.match(/[\\d]+ hour/) || [0])[0], 10);\n    //                     var minutes = parseFloat((route.legs[0].duration.text.match(/[\\d]+ min/) || [0])[0], 10);\n    //                     var total = hours * 60 + minutes;\n    //                     return total;\n    //                 });\n    //                 const minDistance = Math.min(...distances);\n    //                 const minDuration = Math.min(...durations);\n    //                 var carbonEmissionInKg;\n    //                 switch (travelMode) {\n    //                     case 'DRIVING':\n    //                         carbonEmissionInKg = 0.251 * minDistance;\n    //                         break;\n    //                     case 'TRANSIT':\n    //                         carbonEmissionInKg = 0.129 * minDistance;\n    //                         break;\n    //                     default:\n    //                         carbonEmissionInKg = 0;\n    //                         break;\n    //                 }\n    //                 var footprintInfo = {\n    //                     travelMode: travelMode,\n    //                     duration: minDuration,\n    //                     distance: minDistance,\n    //                     footprint: carbonEmissionInKg,\n    //                     response: response\n    //                 };\n    //                 resolve(footprintInfo);\n    //             } else {\n    //                 window.alert('Directions request failed due to ' + status);\n    //                 reject('Directions request failed due to ' + status);\n    //             }\n    //         });\n    //     })\n    // }\n  }\n\n  getFootprint(DirectionsService, origin, destination, travelMode, // setEmission,\n  option = 'departureTime', time = new Date()) {\n    return new Promise((resolve, reject) => {\n      DirectionsService.route({\n        origin: origin,\n        destination: destination,\n        travelMode: travelMode,\n        provideRouteAlternatives: true,\n        transitOptions: {\n          [option]: time // departureTime: new Date()\n\n        }\n      }, (response, status) => {\n        if (status === 'OK') {\n          const distances = response.routes.map(route => {\n            return parseFloat(route.legs[0].distance.text.split(' ')[0], 10);\n          });\n          const durations = response.routes.map(route => {\n            var hours = parseFloat((route.legs[0].duration.text.match(/[\\d]+ hour/) || [0])[0], 10);\n            var minutes = parseFloat((route.legs[0].duration.text.match(/[\\d]+ min/) || [0])[0], 10);\n            var total = hours * 60 + minutes;\n            return total;\n          });\n          const minDistance = Math.min(...distances);\n          const minDuration = Math.min(...durations);\n          var carbonEmissionInKg;\n\n          switch (travelMode) {\n            case 'DRIVING':\n              carbonEmissionInKg = 0.251 * minDistance;\n              break;\n\n            case 'TRANSIT':\n              carbonEmissionInKg = 0.129 * minDistance;\n              break;\n\n            default:\n              carbonEmissionInKg = 0;\n              break;\n          }\n\n          var footprintInfo = {\n            travelMode: travelMode,\n            duration: minDuration,\n            distance: minDistance,\n            footprint: carbonEmissionInKg,\n            response: response\n          }; // setEmission(carbonEmissionInKg); // Kelly\n\n          resolve(footprintInfo);\n        } else {\n          // window.alert('Directions request failed due to ' + status);\n          reject('Directions request failed due to ' + status);\n        }\n      });\n    });\n  }\n\n  onReady(mapProps, map) {\n    const DirectionsDisplay = new this.google.maps.DirectionsRenderer();\n    DirectionsDisplay.setMap(map);\n    DirectionsDisplay.setPanel(document.getElementById('DirectionsPanel'));\n    this['directionsDisplay'] = DirectionsDisplay;\n    this.props.setRenderMapFunc(() => this.onMapClicked());\n    this.props.setRenderMapFuncWithTMode(this.renderMapWithTMode);\n  } //   static getDerivedStateFromProps(props, state) {\n  //     if (props.travelMode !== state.travelMode) {\n  //       return Object.assign({}, props, { shouldUpdate: true });\n  //     }\n  //     return props;\n  //   }\n\n\n  render() {\n    // if (this.state.shouldUpdate) {\n    // if (this.props.shouldUpdateMap) {\n    //   this.renderMapwithTMode();\n    // }\n    return React.createElement(Map, {\n      google: this.props.google,\n      zoom: 14,\n      initialCenter: this.props.initialCenter,\n      onClick: this.onMapClicked.bind(this),\n      onReady: this.onReady.bind(this),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 275\n      },\n      __self: this\n    }, React.createElement(InfoWindow, {\n      onClose: this.onInfoWindowClose,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 282\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 283\n      },\n      __self: this\n    })));\n  }\n\n}\nexport default GoogleApiWrapper({\n  apiKey: 'AIzaSyDKYcp0aMQXMJYUXSWoiIfnWKtoADcnCXs'\n})(MapContainer);","map":{"version":3,"sources":["D:\\Documents\\MANPRO\\PROJ FIX\\FIX\\footprint-calculator-masta(rev)\\src\\components\\Maps\\map.jsx"],"names":["React","Map","InfoWindow","GoogleApiWrapper","MapContainer","Component","constructor","props","renderMapWithTMode","travelMode","option","time","console","log","responsePromise","getFootprint","directionsService","origin","destination","setState","shouldUpdate","setShouldUpdateMap","then","promise","setEmittedCO2","footprint","directionsDisplay","setDirections","response","state","google","maps","DirectionsService","onMapClicked","setCO2","DirectionsDisplay","footprintPromises","Promise","all","arr","footprints","reduce","acc","curr","bestRoute","duration","setTravelMode","Date","resolve","reject","route","provideRouteAlternatives","transitOptions","status","distances","routes","map","parseFloat","legs","distance","text","split","durations","hours","match","minutes","total","minDistance","Math","min","minDuration","carbonEmissionInKg","footprintInfo","onReady","mapProps","DirectionsRenderer","setMap","setPanel","document","getElementById","setRenderMapFunc","setRenderMapFuncWithTMode","render","initialCenter","bind","onInfoWindowClose","apiKey"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { Map, InfoWindow, GoogleApiWrapper } from 'google-maps-react';\n\nexport class MapContainer extends React.Component {\n  // travel modes:\n  //  - driving\n  //  - bicycling\n  //  - transit\n  //  - walking\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      travelMode: props.travelMode\n      //   shouldUpdate: false\n    };\n    this.google = this.props.google;\n    this.directionsService = new this.google.maps.DirectionsService();\n  }\n\n  onMapClicked() {\n    const origin = this.props.origin;\n    const destination = this.props.destination;\n    const setCO2 = this.props.setEmittedCO2;\n    if (!destination || !origin) {\n      return;\n    }\n    const DirectionsDisplay = this.directionsDisplay;\n\n    var footprintPromises = [\n      this.getFootprint(\n        this.directionsService,\n        origin,\n        destination,\n        'TRANSIT'\n        // setCO2\n      ),\n      this.getFootprint(\n        this.directionsService,\n        origin,\n        destination,\n        'DRIVING'\n        // setCO2\n      ),\n      this.getFootprint(\n        this.directionsService,\n        origin,\n        destination,\n        'WALKING'\n        // setCO2\n      ),\n      this.getFootprint(\n        this.directionsService,\n        origin,\n        destination,\n        'BICYCLING'\n        // setCO2\n      )\n    ];\n\n    Promise.all(footprintPromises).then(arr => {\n      console.log(arr);\n\n      var footprints = arr.reduce((acc, curr) => {\n        acc[curr.travelMode] = curr;\n        return acc;\n      }, {});\n\n      var bestRoute = footprints['DRIVING'];\n\n      // if walking to feasible\n      if (footprints['WALKING'].duration < 30) {\n        bestRoute = footprints['WALKING'];\n      } else {\n        if (footprints['BICYCLING'].duration < 45) {\n          bestRoute = footprints['BICYCLING'];\n        } else {\n          if (\n            footprints['TRANSIT'].footprint <=\n              footprints['DRIVING'].footprint &&\n            footprints['TRANSIT'].duration - footprints['DRIVING'].duration < 30\n          ) {\n            bestRoute = footprints['TRANSIT'];\n          }\n        }\n      }\n\n      console.log(bestRoute);\n      this.props.setTravelMode(bestRoute.travelMode);\n      this.props.setEmittedCO2(bestRoute.footprint);\n      DirectionsDisplay.setDirections(bestRoute.response);\n      // window.alert(`${bestRoute.travelMode}: footprint: ${bestRoute.footprint}kg`);\n    });\n\n    // function getFootprint(travelMode) {\n    //     return new Promise((resolve, reject) => {\n\n    //         DirectionsService.route({\n    //             origin: origin,\n    //             destination: destination,\n    //             travelMode: travelMode,\n    //             provideRouteAlternatives: true,\n    //             transitOptions: {\n    //                 departureTime: new Date()\n    //             }\n    //         }, (response, status) => {\n    //             if (status === 'OK') {\n    //                 const distances = response.routes.map(route => {\n    //                     return parseFloat(route.legs[0].distance.text.split(' ')[0], 10);\n    //                 });\n    //                 const durations = response.routes.map(route => {\n    //                     var hours = parseFloat((route.legs[0].duration.text.match(/[\\d]+ hour/) || [0])[0], 10);\n\n    //                     var minutes = parseFloat((route.legs[0].duration.text.match(/[\\d]+ min/) || [0])[0], 10);\n\n    //                     var total = hours * 60 + minutes;\n    //                     return total;\n    //                 });\n\n    //                 const minDistance = Math.min(...distances);\n    //                 const minDuration = Math.min(...durations);\n    //                 var carbonEmissionInKg;\n\n    //                 switch (travelMode) {\n    //                     case 'DRIVING':\n    //                         carbonEmissionInKg = 0.251 * minDistance;\n    //                         break;\n    //                     case 'TRANSIT':\n    //                         carbonEmissionInKg = 0.129 * minDistance;\n    //                         break;\n    //                     default:\n    //                         carbonEmissionInKg = 0;\n    //                         break;\n    //                 }\n\n    //                 var footprintInfo = {\n    //                     travelMode: travelMode,\n    //                     duration: minDuration,\n    //                     distance: minDistance,\n    //                     footprint: carbonEmissionInKg,\n    //                     response: response\n    //                 };\n    //                 resolve(footprintInfo);\n    //             } else {\n    //                 window.alert('Directions request failed due to ' + status);\n    //                 reject('Directions request failed due to ' + status);\n    //             }\n    //         });\n    //     })\n    // }\n  }\n\n  renderMapWithTMode = (travelMode = this.props.travelMode, option, time) => {\n    console.log('Should update! Travel mode is ' + travelMode);\n\n    var responsePromise = this.getFootprint(\n      this.directionsService,\n      this.props.origin,\n      this.props.destination,\n      //   this.props.setEmittedCO2,\n      travelMode,\n      option,\n      time\n    );\n    this.setState({ shouldUpdate: false });\n    this.props.setShouldUpdateMap(false);\n    responsePromise.then(promise => {\n      this.props.setEmittedCO2(promise.footprint);\n      this.directionsDisplay.setDirections(promise.response);\n    });\n  };\n\n  getFootprint(\n    DirectionsService,\n    origin,\n    destination,\n    travelMode,\n    // setEmission,\n    option = 'departureTime',\n    time = new Date()\n  ) {\n    return new Promise((resolve, reject) => {\n      DirectionsService.route(\n        {\n          origin: origin,\n          destination: destination,\n          travelMode: travelMode,\n          provideRouteAlternatives: true,\n          transitOptions: {\n            [option]: time\n            // departureTime: new Date()\n          }\n        },\n        (response, status) => {\n          if (status === 'OK') {\n            const distances = response.routes.map(route => {\n              return parseFloat(route.legs[0].distance.text.split(' ')[0], 10);\n            });\n            const durations = response.routes.map(route => {\n              var hours = parseFloat(\n                (route.legs[0].duration.text.match(/[\\d]+ hour/) || [0])[0],\n                10\n              );\n\n              var minutes = parseFloat(\n                (route.legs[0].duration.text.match(/[\\d]+ min/) || [0])[0],\n                10\n              );\n\n              var total = hours * 60 + minutes;\n              return total;\n            });\n\n            const minDistance = Math.min(...distances);\n            const minDuration = Math.min(...durations);\n            var carbonEmissionInKg;\n\n            switch (travelMode) {\n              case 'DRIVING':\n                carbonEmissionInKg = 0.251 * minDistance;\n                break;\n              case 'TRANSIT':\n                carbonEmissionInKg = 0.129 * minDistance;\n                break;\n              default:\n                carbonEmissionInKg = 0;\n                break;\n            }\n\n            var footprintInfo = {\n              travelMode: travelMode,\n              duration: minDuration,\n              distance: minDistance,\n              footprint: carbonEmissionInKg,\n              response: response\n            };\n\n            // setEmission(carbonEmissionInKg); // Kelly\n\n            resolve(footprintInfo);\n          } else {\n            // window.alert('Directions request failed due to ' + status);\n            reject('Directions request failed due to ' + status);\n          }\n        }\n      );\n    });\n  }\n\n  onReady(mapProps, map) {\n    const DirectionsDisplay = new this.google.maps.DirectionsRenderer();\n    DirectionsDisplay.setMap(map);\n    DirectionsDisplay.setPanel(document.getElementById('DirectionsPanel'));\n\n    this['directionsDisplay'] = DirectionsDisplay;\n    this.props.setRenderMapFunc(() => this.onMapClicked());\n    this.props.setRenderMapFuncWithTMode(this.renderMapWithTMode);\n  }\n\n  //   static getDerivedStateFromProps(props, state) {\n  //     if (props.travelMode !== state.travelMode) {\n  //       return Object.assign({}, props, { shouldUpdate: true });\n  //     }\n\n  //     return props;\n  //   }\n\n  render() {\n    // if (this.state.shouldUpdate) {\n    // if (this.props.shouldUpdateMap) {\n    //   this.renderMapwithTMode();\n    // }\n    return (\n      <Map\n        google={this.props.google}\n        zoom={14}\n        initialCenter={this.props.initialCenter}\n        onClick={this.onMapClicked.bind(this)}\n        onReady={this.onReady.bind(this)}\n      >\n        <InfoWindow onClose={this.onInfoWindowClose}>\n          <div />\n        </InfoWindow>\n      </Map>\n    );\n  }\n}\n\nexport default GoogleApiWrapper({\n  apiKey: 'AIzaSyDKYcp0aMQXMJYUXSWoiIfnWKtoADcnCXs'\n})(MapContainer);\n"]},"metadata":{},"sourceType":"module"}